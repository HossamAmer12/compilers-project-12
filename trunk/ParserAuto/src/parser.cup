
import java_cup.runtime.*;
import java.util.ArrayList;
	
/* Terminals (tokens returned by the scanner). */
terminal			SM, PO, MO, TO, DO, NM,FA,LP,RP,RB,LB,AO,MD,EQ,NE,LO,LA,BL,ST,ID,ERROR;
terminal			KW_class, KW_static, KW_else, KW_if, KW_float, KW_boolean, KW_String, KW_return, KW_while, KW_int;
 	
/* Non-terminals */
nonterminal	ClassDecl		ClassDecl;
nonterminal	MethodDecls		MethodDecls;
nonterminal	MethodDecl		MethodDecl;

nonterminal	Type		Type;
nonterminal	Block		Block;
nonterminal	FormalParams		FormalParams;
nonterminal	ProperFormalParams		ProperFormalParams;
nonterminal	FormalParam		FormalParam;
nonterminal	Statements		Statements;
nonterminal	Statement		Statement;

nonterminal	LocalVarDecl		LocalVarDecl;
nonterminal	AssignStmt		AssignStmt;
nonterminal	IfStmt		IfStmt;
nonterminal	WhileStmt		WhileStmt;
nonterminal	ReturnStmt		ReturnStmt;

nonterminal	Expression		Expression;
nonterminal	ConditionalAndExpr		ConditionalAndExpr;
nonterminal	EqualityExpr		EqualityExpr;
nonterminal	AdditiveExpr		AdditiveExpr;
nonterminal	MultiplicativeExpr		MultiplicativeExpr;
nonterminal	PrimaryExpr		PrimaryExpr;
nonterminal	CallExpr		CallExpr;

nonterminal	ActualParams		ActualParams;
nonterminal	ProperActualParams		ProperActualParams;



/* Precedences */
precedence left PO, MO;
precedence left TO, DO;
precedence left KW_else;

/* The grammar */


ClassDecl ::= KW_class ID LB MethodDecls: m  RB
              {:
              	RESULT = new ClassDecl(m);
              :} 
              | error 
              {:
              	RESULT = new ClassDecl();
              :};


MethodDecls ::= MethodDecls:el MethodDecl:e
			  {:
			  	 el.add(e);
			     RESULT = el;
			  :} 
			  |  
			  {: 
			     RESULT = new MethodDecls();
			  :};              

MethodDecl  ::= KW_static Type: t ID: id LP FormalParams: f RP Block: b
				 {:
				 	RESULT = new MethodDecl(t, f, b, id.toString());
				 :};

FormalParams ::= FormalParams:f1 FA FormalParam:f 
				{: 
					f1.add(f);
					RESULT = f1;
				:} 
				| FormalParam: f
				{: 
					FormalParams f1 = new FormalParams();
					f1.add(f);
					RESULT = f1;
				:}
				| 
				{: 
					RESULT = new FormalParams();
				:};


FormalParam ::= Type: t ID: id
				{: 
					RESULT = new FormalParam(id.toString(), t);
				:};

Type ::= KW_int:a
		{: 
			RESULT = new Type(a.toString()); 
		:} 
		| KW_float: b 
		{: 
			RESULT = new Type(b.toString()); 
		:}  
		| KW_boolean: c 
		{: 
			RESULT = new Type(c.toString()); 
		:}  
		| KW_String: d 
		{: 
			RESULT = new Type(d.toString()); 
		:};

Block ::= LB Statements: st RB
		{: 
			RESULT = new Block(st); 
		:};

Statements ::= Statements: stats Statement: st
			{: 
				stats.add(st);
				RESULT = stats;
				
			:}
			| 
			{:
				RESULT = new Statements();
			:};

Statement ::= Block: block
			{:
				RESULT = new Statement(block);
			:}	
			| LocalVarDecl: lv
			{:
				RESULT = new Statement(lv);
			:}
			| AssignStmt: ass
			{:
				RESULT = new Statement(ass);
			:} 
			| IfStmt: ifstmt
			{:
				RESULT = new Statement(ifstmt);
			:} 
			| WhileStmt: whilestmt
			{:
				RESULT = new Statement(whilestmt);
			:} 
			| ReturnStmt: returnstmt
			{:
				RESULT = new Statement(returnstmt);
			:};

LocalVarDecl ::= Type: t ID: id SM
			{:
				RESULT = new LocalVarDecl(id.toString(), t);
			:};	 

AssignStmt ::= ID: id AO Expression: e SM 
			{:	
				RESULT = new AssignStmt(id.toString(), e);
			:};

IfStmt ::= KW_if LP Expression: e RP Statement: stmt KW_else Statement: elsestmt
			{:
				RESULT = new IfStmt(e, stmt, elsestmt);
			:}
			| KW_if LP Expression: e RP Statement: stmt
			{:
				RESULT = new IfStmt(e, stmt); 
			:};


WhileStmt ::= KW_while LP Expression: exp RP Statement: stmt
			{:
				RESULT = new WhileStmt(exp, stmt);
			:};

ReturnStmt ::= KW_return Expression: exp SM 
			{:
				RESULT = new ReturnStmt(exp);
			:};

Expression ::= ConditionalAndExpr: andExp
			{:
				RESULT = andExp;
			:} 
			| Expression: exp LO ConditionalAndExpr: andExp
			{: 
				RESULT = new Expression(andExp, exp);
			:};	

ConditionalAndExpr ::= EqualityExpr: equality
					{:
						RESULT = equality;
					:}
					| ConditionalAndExpr: andExp LA EqualityExpr: equality
					{:
						RESULT = new ConditionalAndExpr(equality, andExp);
					:};

EqualityExpr ::= AdditiveExpr: add
				{:
					RESULT = add;
				:} 
				| EqualityExpr: equality EQ AdditiveExpr: add
				{:
				RESULT = new EqualityExpr(add, EqualityExpr.EQ, equality);
				:} 
				| EqualityExpr: equality NE AdditiveExpr: add
				{:
					RESULT = new EqualityExpr(add, EqualityExpr.NE, equality);
				:};

AdditiveExpr ::= MultiplicativeExpr: multiply
				{:
					 RESULT = multiply;
				:} 
				| AdditiveExpr: add PO MultiplicativeExpr: multiply
				{:
					RESULT = new AdditiveExpr(multiply, AdditiveExpr.PO, add);
				:}		
				 | AdditiveExpr: add MO MultiplicativeExpr: multiply
				 {:
					RESULT = new AdditiveExpr(multiply, AdditiveExpr.MO, add);
				:};


MultiplicativeExpr ::= PrimaryExpr: primary
				{:
					 RESULT = primary;
				:} 
				| MultiplicativeExpr: multiply TO PrimaryExpr: primary
				{:
					RESULT = new MultiplicativeExpr(primary,MultiplicativeExpr.TO, multiply);
				:}		
				 | MultiplicativeExpr: multiply DO PrimaryExpr: primary
				 {:
					RESULT = new MultiplicativeExpr(primary, MultiplicativeExpr.DO, multiply);
				:}
				| MultiplicativeExpr: multiply MD PrimaryExpr: primary
				{:
					RESULT = new MultiplicativeExpr(primary, MultiplicativeExpr.MD, multiply);
				:};

PrimaryExpr ::= NM: nm
				{:
					RESULT = new PrimaryExpr(nm.toString());
				:} 
				| BL: bl
				{:
				 	RESULT = new PrimaryExpr(bl.toString(), null, null);
				:}
				| ST: st
				{:
				 	RESULT = new PrimaryExpr(null, st.toString(), null);;
				:}
				| ID: idLexeme LP ActualParams: act RP
				{:
					 RESULT = new PrimaryExpr(act, idLexeme.toString());
				:}	 
				| ID: idLexeme
				{:
				 	RESULT = new PrimaryExpr(null, null, idLexeme.toString());
				:}  
				| LP Expression: exp RP
				{:
				 	RESULT = new PrimaryExpr(exp);
				:};

ActualParams::= ProperActualParams: pAs
				{:
					RESULT = new ActualParams(pAs);
				:} 
				| 
				{:
					RESULT = null;
				:};

ProperActualParams::= ProperActualParams: pAs FA Expression: exp
					{:
						pAs.add(exp);
						RESULT = pAs;
					:}	 
					| Expression: exp
					{:
						ProperActualParams pAs = new ProperActualParams();
						pAs.add(exp);
					:};
